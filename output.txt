Rule: <program> ===> <otherFunctions> <mainFunction>
Semantic: <program>.node = createNode( <otherFunctions>.node, <mainFunction>.node )
Rule: <mainFunction> ===> TK_MAIN <stmts> TK_END
Semantic: <mainFunction>.node = <stmts>.node
Rule: <otherFunctions> ===> eps
Semantic: <otherFunctions>.node = NULL
Rule: <otherFunctions> ===> <function><otherFunctions1>
Semantic: <otherFunctions>.node = createNode( <function>.node, <otherFunctions1>.node )
Rule: <function> ===> TK_FUNID <input_par> <output_par> TK_SEM <stmts> TK_END
Semantic: <function>.node = createNode( TK_FUNID.node, <input_par>.node, <output_par>.node, <stmts>.node )
Rule: <input_par> ===> TK_INPUT TK_PARAMETER TK_LIST TK_SQL <parameter_list> TK_SQR
Semantic: <input_par>.node = <parameter_list>.node
Rule: <output_par> ==> eps
Semantic: <output_par>.node = NULL
Rule: <output_par> ===> TK_OUTPUT TK_PARAMETER TK_LIST TK_SQL <parameter_list> TK_SQR
Semantic: <output_par>.node = <parameter_list>.node
Rule: <parameter_list> ===> <dataType> TK_ID <remaining_list>
Semantic: <parameter_list>.node = createNode( <dataType>.node, TK_ID.node, <remaining_list>.node )
Rule: <dataType> ===>  <constructedDatatype>
Semantic: <dataType>.node = <constructedDatatype>.node
Rule: <dataType> ===> <primitiveDatatype>
Semantic: <dataType>.node = <primitiveDatatype>.node
Rule: <primitiveDatatype> ===> TK_REAL
Semantic: <primitiveDatatype>.node = TK_REAL.node
Rule: <primitiveDatatype> ===> TK_INT
Semantic: <primitiveDatatype>.node = TK_INT.node
Rule: <constructedDatatype> ===> TK_RECORD TK_RECORDID
Semantic: <constructedDatatype>.node = TK_RECORDID.node
Rule: <remaining_list> ===> eps
Semantic: <remaining_list>.node = NULL
Rule: <remaining_list> ===> TK_COMMA <parameter_list>
Semantic: <remaining_list>.node = <parameter_list>.node
Rule: <stmts> ===> <typeDefinitions> <declarations> <otherStmts><returnStmt>
Semantic: <stmts>.node = createNode( <typeDefinitions>.node, <declarations>.node, <otherStmts>.node, <returnStmt>.node )
Rule: <typeDefinitions> ===> eps
Semantic: <typeDefinitions>.node = NULL
Rule: <typeDefinitions> ===> <typeDefinition><typeDefinitions1>
Semantic: <typeDefinitions>.node = createNode( <typeDefinition>.node, <typeDefinitions1>.node )
Rule: <typeDefinition> ===> TK_RECORD TK_RECORDID <fieldDefinitions> TK_ENDRECORD TK_SEM
Semantic: <typeDefinition>.node = createNode( TK_RECORDID.node, <fieldDefinitions>.node )
Rule: <fieldDefinitions> ===> <fieldDefinition1><fieldDefinition2><moreFields>
Semantic: <fieldDefinitions>.node = createNode( <fieldDefinition1>.node, <fieldDefinition2>.node, <moreFields>.node )
Rule: <fieldDefinition> ===> TK_TYPE <primitiveDatatype> TK_COLON TK_FIELDID TK_SEM
Semantic: <fieldDefinition>.node = createNode( <primitiveDatatype>.node, TK_FIELDID.node )
Rule: <moreFields> ===> eps
Semantic: <moreFields>.node = NULL
Rule: <moreFields> ===> <fieldDefinition><moreFields1>
Semantic: <moreFields>.node = createNode( <fieldDefinition>.node, <moreFields1>.node )
Rule: <declarations> ===> eps
Semantic: <declarations>.node = NULL
Rule: <declarations> ===> <declaration><declarations1>
Semantic: <declarations>.node = createNode( <declaration>.node, <declarations1>.node )
Rule: <declaration> ===> TK_TYPE <dataType> TK_COLON TK_ID <global_or_not> TK_SEM
Semantic: <declaration>.node = createNode( <dataType>.node, TK_ID.node, <global_or_not>.node )
Rule: <global_or_not> ===> eps
Semantic: <global_or_not>.node = NULL
Rule: <global_or_not> ===> TK_COLON TK_GLOBAL
Semantic: <global_or_not>.node = TK_GLOBAL.node
Rule: <otherStmts> ===>  eps
Semantic: <otherStmts>.node = NULL
Rule: <otherStmts> ===> <stmt><otherStmts1>
Semantic: <otherStmts>.node = createNode( <stmt>.node, <otherStmts1>.node )
Rule: <stmt> ===> <funCallStmt>
Semantic: <stmt>.node = <funCallStmt>.node
Rule: <stmt> ===> <assignmentStmt>
Semantic: <stmt>.node = <assignmentStmt>.node
Rule: <stmt> ===> <iterativeStmt>
Semantic: <stmt>.node = <iterativeStmt>.node
Rule: <stmt> ===> <conditionalStmt>
Semantic: <stmt>.node = <conditionalStmt>.node
Rule: <stmt> ===> <ioStmt>
Semantic: <stmt>.node = <ioStmt>.node
Rule: <assignmentStmt> ===> <singleOrRecId> TK_ASSIGNOP <arithmeticExpression> TK_SEM
Semantic: <assignmentStmt>.node = createNode( <singleOrRecId>.node, <arithmeticExpression>.node )
Rule: <singleOrRecId> ===> TK_ID <singleOrRecIdPrime>
Semantic: <singleOrRecId>.node = createNode( TK_ID.node, <singleOrRecIdPrime>.node )
Rule: <singleOrRecIdPrime> ===> eps
Semantic: <singleOrRecIdPrime>.node = NULL
Rule: <singleOrRecIdPrime> ===> TK_DOT TK_FIELDID
Semantic: <singleOrRecIdPrime>.node = TK_FIELDID.node
Rule: <funCallStmt> ===> <outputParameters> TK_CALL TK_FUNID TK_WITH TK_PARAMETERS <inputParameters> TK_SEM
Semantic: <funCallStmt>.node = createNode( <outputParameters>.node, TK_FUNID.node, <inputParameters>.node )
Rule: <outputParameters> ===> eps
Semantic: <outputParameters>.node = NULL
Rule: <outputParameters> ===> TK_SQL <idList> TK_SQR TK_ASSIGNOP
Semantic: <outputParameters>.node = <idList>.node
Rule: <inputParameters> ===> TK_SQL <idList> TK_SQR
Semantic: <inputParameters>.node = <idList>.node
Rule: <iterativeStmt> ===> TK_WHILE TK_OP <booleanExpression> TK_CL <stmt><otherStmts> TK_ENDWHILE
Semantic: <iterativeStmt>.node = createNode( <booleanExpression>.node, <stmt>.node, <otherStmts>.node )
Rule: <conditionalStmt> ===> TK_IF TK_OP <booleanExpression> TK_CL TK_THEN <stmt><otherStmts> <elsePart>
Semantic: <conditionalStmt>.node = createNode( <booleanExpression>.node, <stmt>.node, <otherStmts>.node, <elsePart>.node )
Rule: <elsePart> ===> TK_ENDIF
Semantic: <elsePart>.node = NULL
Rule: <elsePart> ===> TK_ELSE <stmt><otherStmts> TK_ENDIF
Semantic: <elsePart>.node = createNode( <stmt>.node, <otherStmts>.node )
Rule: <ioStmt> ===> TK_READ TK_OP <singleOrRecId> TK_CL TK_SEM
Semantic: <ioStmt>.node = createNode( TK_READ.node, <singleOrRecId>.node )
Rule: <ioStmt> ===> TK_WRITE TK_OP <allVar> TK_CL TK_SEM
Semantic: <ioStmt>.node = createNode( TK_WRITE.node, <allVar>.node )
Rule: <allVar> ===> TK_ID <allVarPrime>
Semantic: <allVar>.node = createNode( TK_ID.node, <allVarPrime>.node )
Rule: <allVar> ===> TK_NUM
Semantic: <allVar>.node = TK_NUM.node
Rule: <allVar> ===> TK_RNUM
Semantic: <allVar>.node = TK_RNUM.node
Rule: <allVarPrime> ===> eps
Semantic: <allVarPrime>.node = NULL
Rule: <allVarPrime> ===> TK_DOT TK_FIELDID
Semantic: <allVarPrime>.node = TK_FIELDID.node
Rule: <arithmeticExpression> ===> <term> <expPrime>
Semantic: <arithmeticExpression>.node = <expPrime>.syn 
		  <expPrime>.inh = <term>.node
Rule: <expPrime> ===> eps
Semantic: <expPrime>.syn = <expPrime>.inh
Rule: <expPrime> ===> <lowPrecedenceOperators> <term> <expPrime>
Semantic: <expPrime1>.inh = createNode( <lowPrecedenceOperators>.node, <expPrime>.inh, <term>.node )
		  <expPrime>.syn = <expPrime1>.syn
Rule: <term> ===> <factor> <termPrime>
Semantic: <term>.node = <termPrime>.syn
		  <termPrime>.inh = <factor>.node
Rule: <termPrime> ===> eps
Semantic: <termPrime>.syn = <termPrime>.inh
Rule: <termPrime> ===> <highPrecedenceOperators><factor> <termPrime>
Semantic: <termPrime1>.node = createNode( <highPrecedenceOperators>.node, <termPrime>.node, <factor>.node )
		  <termPrime>.syn = <termPrime1>.syn
Rule: <factor> ===> <allVar>
Semantic: <factor>.node = <allVar>.node
Rule: <factor> ===> TK_OP <arithmeticExpression> TK_CL
Semantic: <factor>.node = <arithmeticExpression>.node
Rule: <highPrecedenceOperators>===> TK_DIV
Semantic: <highPrecedenceOperators>.node = TK_DIV.node
Rule: <highPrecedenceOperators>===> TK_MUL
Semantic: <highPrecedenceOperators>.node = TK_MUL.node
Rule: <lowPrecedenceOperators> ===> TK_MINUS
Semantic: <lowPrecedenceOperators>.node = TK_MINUS.node
Rule: <lowPrecedenceOperators> ===> TK_PLUS
Semantic: <lowPrecedenceOperators>.node = TK_PLUS.node
Rule: <booleanExpression> ===> TK_OP <booleanExpression1> TK_CL <logicalOp> TK_OP <booleanExpression2> TK_CL
Semantic: <booleanExpression>.node = createNode( <booleanExpression1>.node, <logicalOp>.node, <booleanExpression2>.node )
Rule: <booleanExpression> ===> <var1> <relationalOp> <var2>
Semantic: <booleanExpression>.node = createNode( <var1>.node, <relationalOp>.node, <var2>.node )
Rule: <booleanExpression> ===> TK_NOT TK_OP <booleanExpression1> TK_CL
Semantic: <booleanExpression>.node = createNode( TK_NOT.node, <booleanExpression1>.node )
Rule: <var> ===> TK_ID
Semantic: <var>.node = TK_ID.node
Rule: <var> ===> TK_NUM
Semantic: <var>.node = TK_NUM.node
Rule: <var> ===> TK_RNUM
Semantic: <var>.node = TK_RNUM.node
Rule: <logicalOp> ===> TK_OR
Semantic: <logicalOp>.node = TK_OR.node
Rule: <logicalOp> ===> TK_AND
Semantic: <logicalOp>.node = TK_AND.node
Rule: <relationalOp> ===> TK_LT
Semantic: <relationalOp>.node = TK_LT.node
Rule: <relationalOp> ===> TK_LE
Semantic: <relationalOp>.node = TK_LE.node
Rule: <relationalOp> ===> TK_EQ
Semantic: <relationalOp>.node = TK_EQ.node
Rule: <relationalOp> ===> TK_GT
Semantic: <relationalOp>.node = TK_GT.node
Rule: <relationalOp> ===> TK_GE
Semantic: <relationalOp>.node = TK_GE.node
Rule: <relationalOp> ===> TK_NE
Semantic: <relationalOp>.node = TK_NE.node
Rule: <returnStmt> ===> TK_RETURN <optionalReturn> TK_SEM
Semantic: <returnStmt>.node = <optionalReturn>.node
Rule: <optionalReturn> ===> eps
Semantic: <optionalReturn>.node = NULL
Rule: <optionalReturn> ===> TK_SQL <idList> TK_SQR
Semantic: <optionalReturn>.node = <idList>.node
Rule: <idList> ===> TK_ID <more_ids>
Semantic: <idList>.node = createNode( TK_ID.node, <more_ids>.node )
Rule: <more_ids> ===> eps
Semantic: <more_ids>.node = NULL
Rule: <more_ids> ===> TK_COMMA <idList>
Semantic: <more_ids>.node = <idList>.node


Assumptions:
1. The method createNode(param1, ..., paramn) creates a node with param1, ..., paramn as its n children. It then returns the pointer to this newly created node which is stored in the 'node' attribute of the lhs.
2. The nonterminals <expPrime> and <termPrime> have two attributes : syn (synthesized attribute) and inh (inherited attribute).